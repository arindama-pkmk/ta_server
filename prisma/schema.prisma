datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String   @id @default(uuid())
  name          String
  username      String   @unique
  email         String   @unique
  password      String
  address       String?
  birthdate     DateTime?
  occupationId  String?
  occupation    Occupation? @relation(fields: [occupationId], references: [id])
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  deletedAt     DateTime?

  transactions        Transaction[]
  otpVerifications    OtpVerification[]
  budgetPlans         BudgetPlan[]       // User has many BudgetPlans
  evaluationResults   EvaluationResult[] // User has many EvaluationResults
}

model Occupation {
  id                  String   @id @default(uuid())
  name                String   @unique
  users               User[]
  categoryOccupations CategoryOccupation[]
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  deletedAt           DateTime?
}

model AccountType {
  id         String     @id @default(uuid())
  name       String     @unique
  categories Category[]
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  deletedAt  DateTime?
}

model Category {
  id                  String                @id @default(uuid())
  name                String
  accountTypeId       String
  accountType         AccountType           @relation(fields: [accountTypeId], references: [id])
  subcategories       Subcategory[]
  categoryOccupations CategoryOccupation[]
  expenseAllocations  ExpenseAllocation[]   // Relation to ExpenseAllocation

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@unique([name, accountTypeId], name: "uniq_category_account_type")
  @@index([accountTypeId])
}

model Subcategory {
  id        String   @id @default(uuid())
  name      String
  categoryId String
  category  Category @relation(fields: [categoryId], references: [id])

  transactions       Transaction[]
  ratioComponents    RatioComponent[]
  expenseAllocations ExpenseAllocation[] // Relation to ExpenseAllocation

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@unique([name, categoryId], name: "uniq_subcategory_category")
  @@index([categoryId])
}

model Transaction {
  id            String      @id @default(uuid())
  description   String
  amount        Float
  date          DateTime
  isBookmarked  Boolean     @default(false)
  userId        String
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  subcategoryId String
  subcategory   Subcategory @relation(fields: [subcategoryId], references: [id])

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@index([userId])
  @@index([subcategoryId])
  @@index([date])
}

model OtpVerification {
  id        String    @id @default(uuid())
  email     String
  otp       String
  expiresAt DateTime
  userId    String?
  user      User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@index([email])
  @@index([userId])
}

// --- Budgeting ---
model CategoryOccupation {
  id           String     @id @default(uuid())
  occupationId String
  occupation   Occupation @relation(fields: [occupationId], references: [id])
  categoryId   String
  category     Category   @relation(fields: [categoryId], references: [id])
  lowerBound   Float?
  upperBound   Float?
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([categoryId, occupationId], name: "uniq_category_occupation")
  @@index([categoryId])
  @@index([occupationId])
}

model BudgetPlan {
  id                         String    @id @default(uuid())
  userId                     String
  user                       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  description                String?   // User-defined name for the budget plan
  planStartDate              DateTime  // Start date for which expenses are budgeted
  planEndDate                DateTime  // End date for which expenses are budgeted
  incomeCalculationStartDate DateTime  // Start date of the period used for income calculation
  incomeCalculationEndDate   DateTime  // End date of the period used for income calculation
  totalCalculatedIncome      Decimal   // The sum of selected incomes for THIS plan

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  allocations ExpenseAllocation[] // A BudgetPlan has many ExpenseAllocations

  // A user can't have two budget plans with the same description for the exact same plan dates
  @@unique([userId, planStartDate, planEndDate, description], name: "uniq_user_budget_plan_dates_desc")
  @@index([userId])
  @@index([userId, planStartDate, planEndDate])
}

model ExpenseAllocation {
  id            String     @id @default(uuid())
  budgetPlanId  String
  budgetPlan    BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)

  categoryId    String
  category      Category   @relation(fields: [categoryId], references: [id])
  subcategoryId String
  subcategory   Subcategory @relation(fields: [subcategoryId], references: [id])

  percentage    Decimal // Percentage of budgetPlan.totalCalculatedIncome for this category
  amount        Decimal // Actual monetary amount allocated for THIS CATEGORY (percentage * totalCalculatedIncome)
                        // If you want amount per subcategory, this model would need to change
                        // or you would have one ExpenseAllocation per subcategory.
                        // Current PSPEC implies amount is for parent category.

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@index([budgetPlanId])
  @@index([categoryId])
  @@index([subcategoryId])
}

// --- Evaluation ---
model Ratio {
  id                      String   @id @default(uuid())
  code                    String   @unique
  title                   String
  description             String?
  multiplier              Float?   @default(1)
  lowerBound              Float?
  upperBound              Float?
  isLowerBoundInclusive   Boolean? @default(true)
  isUpperBoundInclusive   Boolean? @default(true)
  idealText               String?

  ratioComponents   RatioComponent[]
  evaluationResults EvaluationResult[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model RatioComponent {
  id              String          @id @default(uuid())
  ratioId         String
  ratio           Ratio           @relation(fields: [ratioId], references: [id], onDelete: Cascade)
  subcategoryId   String
  subcategory     Subcategory     @relation(fields: [subcategoryId], references: [id])
  side            Side
  sign            Int
  aggregationType AggregationType

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

@@unique([ratioId, subcategoryId, side], name: "uniq_ratio_subcategory_side")
  @@index([ratioId])
  @@index([subcategoryId])
}

model EvaluationResult {
  id        String   @id @default(uuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  startDate DateTime // Start of the ad-hoc evaluation period
  endDate   DateTime // End of the ad-hoc evaluation period
  ratioId   String
  ratio     Ratio    @relation(fields: [ratioId], references: [id])

  value        Float
  status       EvaluationStatus
  calculatedAt DateTime         @default(now())

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  @@unique([userId, ratioId, startDate, endDate], name: "uniq_user_eval_result_dates")
  @@index([userId])
  @@index([ratioId])
}

enum Side {
  numerator
  denominator
}

enum AggregationType {
  SUM
  AVG
}

enum EvaluationStatus {
  IDEAL
  NOT_IDEAL
  INCOMPLETE
}