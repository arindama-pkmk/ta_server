// src/repositories/userRepository.ts
import { PrismaClient, User, Prisma, Occupation } from '@prisma/client';
import { inject, injectable } from 'inversify';
import { TYPES } from '../utils/types';

// DTO for user creation, omitting fields generated by DB or derived
export type CreateUserDto = Omit<User, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt' | 'occupation'> & {
    occupationId?: string; // Client sends occupationId
};

// DTO for user update, all fields optional
export type UpdateUserDto = Partial<Omit<User, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt' | 'email' | 'password' | 'occupation'>> & {
    occupationId?: string;
    // Password changes should be handled by a separate, more secure process
    // Email changes often require re-verification
};


@injectable()
export class UserRepository {
    private readonly prisma: PrismaClient;

    constructor(@inject(TYPES.PrismaClient) prisma: PrismaClient) {
        this.prisma = prisma;
    }

    async create(data: CreateUserDto): Promise<User> {
        // occupationId is already part of CreateUserDto
        return this.prisma.user.create({
            data: {
                name: data.name,
                username: data.username,
                email: data.email,
                password: data.password, // Password should already be hashed by the service
                address: data.address,
                birthdate: data.birthdate,
                occupationId: data.occupationId,
            },
            include: { occupation: true } // Include occupation details on creation
        });
    }

    async findAll(args?: Prisma.UserFindManyArgs): Promise<User[]> {
        const queryArgs = { ...args };
        queryArgs.where = {
            ...(args?.where || {}),
            deletedAt: null, // Default: Exclude soft-deleted
        };
        return this.prisma.user.findMany(queryArgs);
    }

    async findById(id: string, includeOccupation: boolean = false): Promise<(User & { occupation?: Occupation | null }) | null> {
        return this.prisma.user.findFirst({ // findFirst to combine where clauses
            where: {
                id,
                deletedAt: null, // Exclude soft-deleted
            },
            include: {
                occupation: includeOccupation,
            }
        });
    }

    async findByEmail(email: string, includeOccupation: boolean = false): Promise<(User & { occupation?: Occupation | null }) | null> {
        return this.prisma.user.findFirst({
            where: {
                email,
                deletedAt: null,
            },
            include: {
                occupation: includeOccupation,
            }
        });
    }

    async findByUsername(username: string, includeOccupation: boolean = false): Promise<(User & { occupation?: Occupation | null }) | null> {
        return this.prisma.user.findFirst({
            where: {
                username,
                deletedAt: null,
            },
            include: {
                occupation: includeOccupation,
            }
        });
    }

    async updateProfile(id: string, data: UpdateUserDto): Promise<User> {
        const { occupationId, ...restOfData } = data;
        const updatePayload: Prisma.UserUpdateInput = { ...restOfData };
        if (occupationId) {
            updatePayload.occupation = { connect: { id: occupationId } };
        }

        return this.prisma.user.update({
            where: { id, deletedAt: null },
            data: updatePayload,
            include: { occupation: true }
        });
    }

    // New specific method for updating password
    async updatePassword(userId: string, newHashedPassword: string): Promise<User> {
        return this.prisma.user.update({
            where: { id: userId, deletedAt: null }, // Ensure user is active
            data: { password: newHashedPassword },
            include: { occupation: true } // Consistent return
        });
    }

    // Soft delete
    async softDelete(id: string): Promise<User> {
        // Cascading soft deletes for related data would be handled in the service layer
        return this.prisma.user.update({
            where: { id },
            data: { deletedAt: new Date() },
            include: { occupation: true }
        });
    }

    // Hard delete (use with caution)
    async hardDelete(id: string): Promise<User> {
        return this.prisma.user.delete({
            where: { id },
        });
    }

    // Restore a soft-deleted user
    async restore(id: string): Promise<User> {
        return this.prisma.user.update({
            where: { id }, // Can restore even if deletedAt is set
            data: { deletedAt: null },
            include: { occupation: true }
        });
    }

    async findAllOccupations(): Promise<Occupation[]> {
        return this.prisma.occupation.findMany({
            where: { deletedAt: null }, // Assuming occupations can be soft-deleted
            orderBy: { name: 'asc' }
        });
    }
}